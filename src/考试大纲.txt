1.聚合初始化 {{1,2},3}
2.结构化绑定  auto []
3.多重继承  菱形缺陷  虚拟继承来解决这个问题 共同基类只有一份 子类会多一个指针 指向一个数字，记录该类首地址与父类首地址（往往在基类后面）的字节差距
4.智能指针  shared_ptr (不正当使用 不要写出独立的shared_ptr 不与裸指针混用 不要保存p.get() )  循环引用就是用weak_ptr   unique_ptr  也不能与裸指针混用  u.release()的返回值必须释放
5.std::variant
6.lambda auto f = [函数对象参数](函数参数列表) mutable throw(类型)->返回值类型 {函数语句};   
7.函数模板  实例化问题
8.可变参数模板 产品里代码
9.模板元编程 模板函数重载
10.std::optional 

clean code 


1.auto 能否推到出引用 根据函数返回值 结构化绑定的推导是否能推出引用
2.lambda获取值的副本存在哪里
3.